#include "cache_reader.h"
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>

//http://www.phim.unibe.ch/comp_doc/c_manual/C/SYNTAX/struct.html
//http://vergil.chemistry.gatech.edu/resources/programming/c-tutorial/structs.html

int refill(cr_file* buff){
  //Refills a buffer
  //Only works when completely used buffer
  if(buff->usedbuffer!=buff->bufferlength)
    return 0;
    else{
      buff->usedbuffer=0;
      int len=read(buff->file,buff->buffer, buff->bufferlength);
      int i;
      //If we didn't fill the buffer, fill up with EOF
      if(len<buff->bufferlength)
        for(i=len;i<buff->bufferlength;i++)
          buff->buffer[i]=EOF;  //Accessing like an array!
          buff->byte_tot +=len; //Adding len to the byte total.
          return len;
        }

      }

      void cr_close(cr_file* f){
        free(f->buffer);
        close(f-> file);
      }
	//---------------------------------------------------------
      cr_file* cr_open(char * filename, int buffersize){

        //Info on malloc
        //http://www.space.unibe.ch/comp_doc/c_manual/C/FUNCTIONS/malloc.html
        int f;
        f = open(filename, O_RDONLY);
        if ( f < 0){
          fprintf(stderr, "Cannot open %s\n", filename);
          return 0;
        }

        cr_file* a=(cr_file*)malloc(sizeof(cr_file));
        a->file=f;
        a->bufferlength=buffersize;
	//Start off with no characters, so refill will work as expected
        a->usedbuffer=buffersize; 
        a->buffer=(char*)malloc(sizeof(char)*buffersize);
        a->byte_tot =0;
        refill(a);
        return a;
      }
      //------------------------------------------------------------------
      char cr_read_byte(cr_file* f){

        char btoRet; // byte to hold the character to return.
	// if the buffer is all used, refill()
        if (f->usedbuffer >= f->bufferlength){ 

	// starts a new line very time the buffer needs to be refilled.
        //  printf(" \n "); 
          refill(f);
        }
// If buffer hasn't been fully used, return the chracater
// and increase the usedBuffer position by 1.
        else{ 

	//Place next character in the btoRet variable.
        btoRet = f->buffer[f->usedbuffer]; 

        f->usedbuffer +=1; //Move the buffer position up by 1.
        return btoRet; //return the varibale.

      }

    }
